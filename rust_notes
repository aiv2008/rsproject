1.unsafe 的超能力
unsafe 能赋予我们 5 种超能力，这些能力在安全的 Rust 代码中是无法获取的：

.解引用裸指针，就如上例所示
.调用一个 unsafe 或外部的函数
.访问或修改一个可变的静态变量
.实现一个 unsafe 特征
.访问 union 中的字段

2. 我们已经学过三种类似指针的概念：引用、智能指针和裸指针。与前两者不同，裸指针：

.可以绕过 Rust 的借用规则，可以同时拥有一个数据的可变、不可变指针，甚至还能拥有多个可变的指针
.并不能保证指向合法的内存
.可以是 null
.没有实现任何自动的回收 (drop)
总之，裸指针跟 C 指针是非常像的，使用它需要以牺牲安全性为前提，但我们获得了更好的性能，也可以跟其它语言或硬件打交道

3. 无论怎样，安全 Rust 都不会导致未定义行为。

.安全/不安全分离的设计意味着安全 Rust 和不安全 Rust 之间存在着不对称的信任关系。安全 Rust 本质上必须相信它所接触的任何不安全 Rust 都是正确编写的。另一方面，不安全的 Rust 在信任安全 Rust 时必须非常小心。
.不安全的 Rust 代码不能相信安全的 Rust 代码会被正确编写。也就是说，如果你输入了没有总排序的值，BTreeMap仍然会表现得完全不正常。它只是不会导致未定义行为。

4. Rust 在其他方面对其他可疑的操作是相当宽容的。Rust 认为以下情况是“安全的”：

.死锁
.有一个数据竞争
.内存泄漏
.未能调用解构器
.整数溢出
.中止程序
.删除生产数据库

然而任何真正可能做这种事情的程序都是_可能_不正确的，Rust 提供了很多工具来尽可能检查出这些问题，但要这些问题完全被预防是不现实的。

5. 宏
.在 Rust 中宏分为两大类：声明式宏( declarative macros ) macro_rules! 和三种过程宏( procedural macros ):
#[derive]，在之前多次见到的派生宏，可以为目标结构体或枚举派生指定的代码，例如 Debug 特征
类属性宏(Attribute-like macro)，用于为目标添加自定义的属性
类函数宏(Function-like macro)，看上去就像是函数调用

.宏和函数的区别
元编程:
可变参数: Rust 的函数签名是固定的：定义了两个参数，就必须传入两个参数，多一个少一个都不行，对于从 JS/TS 过来的同学，这一点其实是有些恼人的。
而宏就可以拥有可变数量的参数，例如可以调用一个参数的 println!("hello")，也可以调用两个参数的 println!("hello {}", name)。
宏展开: 
由于宏会被展开成其它代码，且这个展开过程是发生在编译器对代码进行解释之前。因此，宏可以为指定的类型实现某个特征：先将宏展开成实现特征的代码后，再被编译。
而函数就做不到这一点，因为它直到运行时才能被调用，而特征需要在编译期被实现。
宏的缺点: 
相对函数来说，由于宏是基于代码再展开成代码，因此实现相比函数来说会更加复杂，再加上宏的语法更为复杂，最终导致定义宏的代码相当地难读，也难以理解和维护。

6. 关于unsafe 裸指针的问题？
.为啥以下代码调用时候，new_node地址不变？

    fn push(&mut self, elem: T){
        let mut new_node = Node{
            elem: elem,
            //next: ptr::null_mut(),
            next: self.head,
        } ;
        println!("new_node = {:?}",new_node);
        let ptr_node: *mut _ = &mut new_node as *mut _; //多次调用push ptr_node地址不变
        //let ptr_node: *mut _ = Box::into_raw(Box::new(new_node)); //多次调用，ptr_node地址会变
        self.head = ptr_node;
    }
